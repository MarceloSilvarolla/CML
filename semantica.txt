===Domĩnios sintáticos:
Identifier = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "IDENTIFIER"
Literal = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "literal" abaixo
Expression = conjunto de todas sequências finitas de terminais deriváveis a partir do não-terminal "e"
Command = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "c"
Declaration = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "dec"
FunctionDefinition = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "f_def"
Program = conjunto de todas as sequências finitas de terminais deriváveis a partir do não-terminal "prog"

===Sintaxe abstrata:
Expressões:
a := "{" "}" | "{" seq_e "}"
seq_e := e | seq_e "," e
ae := IDENTIFIER | ae "[" e "]"
e := IDENTIFIER | literal | a | e "||" e | ae "=" e | e "&&" e | e "==" e | e "!=" e |
     e "<" e | e "<=" e | e ">" e | e ">=" e | "-" e | e "+" e | e "-" e | e "*" e | e "/" e | "(" e ")" |
     e "[" e "]" | e "(" ")" | e "(" seq_e ")" | "!" e
Comandos (s de statement, mudar para comando):
s := c_s | e_s | s_s | i_s | j_s
c_s := "{" SKIP ";" "}" | "{" seq_b_i "}"
e_s := e ";"
s_s := IF "(" e ")" c_s ELSE c_s | IF "(" e ")" c_s
i_s := WHILE "(" e ")" s
j_s := RETURN ";" | RETURN e ";"

b_i := d | s
seq_b_i := b_i | seq_b_i b_i

Declarações:
dec := type_specifier IDENTIFIER ";" | type_specifier IDENTIFIER "=" e ";" | type_specifier IDENTIFIER "(" ")" ";" |
     type_specifier IDENTIFIER "(" seq_p_dec ")" ";"

p_dec := type_specifier IDENTIFIER
seq_p_dec := p_dec | seq_p_dec "," p_dec

Definições:
f_def := type_specifier IDENTIFIER "(" ")" c_s | type_specifier IDENTIFIER "(" seq_p_dec ")" c_s

Programa:
prog := e_dec | prog e_dec
e_dec := f_def | dec

===Domínios semânticos:

Denotamos por X-->Y o conjunto de funções de X em Y. Escrevemos f:X-->Y para dizer que f é função de X em Y.
X + Y denota a união disjunta de X com Y, ié, X x {0} união Y x {1}

Int = {..., -2, -1, 0, 1, 2, ...} = \mathbb{Z}
Real = \mathbb{R}
Bool = {true, false}
Char = {0, ..., 127}
    onde os números de 0 a 127 são interpretados conforme o padrão ASCII, e.g., 43 representa '+', 49 representa '1', etc.
String = Char* = união para todo i em {0, 1, 2, ...} de Char^i
    onde * é a estrela de Kleene
    e Char^i = {s | s:{1, 2, ..., i} --> Char} = {1, 2, ..., i} --> Char
Dataset = {0, ..., n} x {1, ..., m} --> Int + Real + String
Model = Dataset --> Dataset
Array = ...
Function = união para i em {0, 1, ...} de (StorableValue^i --> StorableValue)
Sigma = ...
StorableValue = int(Int) + real(Real) + bool(Bool) + char(Char) + string(String) + dataset(Dataset) + model(Model) + array(Array)
ExpressibleValue = StorableValue + Function

Obs.: acrescentamos o valor especial error em todos os domínios, para indicar erro no programa

===Funções semânticas:
E:Expression --> (Sigma --> ExpressibleValue)
C:Command --> (Sigma --> Sigma)
Dec:Declaration --> (Sigma --> Sigma)
Def:FunctionDefinition --> (Sigma --> Sigma)
P:Program --> (Sigma --> Sigma )

===Equações semânticas:
P[[dec]] sig = Dec[[dec]] sig
P[[f_def]] sig = Def[[f_def]]
P[[prog e_dec]] sig = P[[e_dec]] (P[[prog]] sig)

E[[IDENTIFIER]] sig = if val = undefined then error else val
                       where val = getIdentifierValue(sig, IDENTIFIER)
E[[INT_LITERAL]] sig = value(INT_LITERAL)
...
E[[STRING_LITERAL]] sig = value(STRING_LITERAL)
E[[{}]] sig = \emptyset
E[[{e}]] sig = array(E[[e]] sig)
value é uma função auxiliar que extrai o valor de um literal. Por exemplo,
value(101) = 101
value(true) = true
value(5.2) = 5,2
value("Maria") = "Maria"

E[[e_1 + e_2]] sig = int(m + n) where int(m) = E[[e_1]] sig and int(n) = E[[e_2]] sig
                   = real(m + n) where int(m) = E[[e_1]] sig and real(n) = E[[e_2]] sig
                   = real(m + n) where real(m) = E[[e_1]] sig and int(n) = E[[e_2]] sig
                   = real(m + n) where real(m) = E[[e_1]] sig and real(n) = E[[e_2]] sig
